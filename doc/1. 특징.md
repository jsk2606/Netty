### 1. Blocking, NonBlocking Socket
* Blocking Socket 설명  
1. 서버는 비즈니스 로직에 따라 클라이언트의 입력을 ***대기하는 시간*** 이 생긴다. 클라이언트는 응답받은 데이터를 ***처리하는 시간*** 이 생긴다.  
2. 순차적으로 작업이 진행된다. 작업의 양과 병목현상이 비례한다. 이 현상을 설명하자면 조금 길어진다.  
첫째로 가비지컬렉션의 힙에있는 자원을 처리하는 동안 다른 스레드는 동작을 멈추게된다.  
대기하는 클라이언트가 많아지면 힙에 스레드가 많이 쌓이고 당연히 힙의 크기는 점점 커진다.  
힙이 커졌으니 가비지컬렉션의 처리공간이 늘어나므로 처리시간이 늘어나고, 스레드가 멈추는 시간이 길어진다.  
둘째로 컨텍스트스위칭으로 인한 CPU 자원의 고갈이다. 컨텍스트스위칭은 스레드들이 본인의 상태를 변경하는 것인데, 이것또한 CPU의 자원을 소모한다.  
이로써 스레드 작업에 쓰이는 자원이 줄어들게된다.

* NonBlocking Socket
1. Blocking Socket 방식의 I/O 처리시간 문제점을 해결한 방식이다.
2. Blocking Socket 방식보다 I/O 처리 로직이 더 복잡하다.

### 2. 이벤트기반 프로그래밍
이벤트를 먼저 정의해두고 발생한 이벤트에 따라서 코드가 실행되도록 프로그램을 작성하는 방식.  
이벤트 추상화가 단순하면 기능이 몰려서 성능에 문제가 생기고  세부적이면 구현시 기능제어가 힘들어진다.  
예를들어 피아노를 친다고 생각보자. 1옥타브 도, 2옥타브 도, 3옥타브 도 3개의 음을 누르려고 한다.  
건반이 7개만 있는 피아노는 같은 도 건반을 3번 눌러야한다.
건반이 21개 있는 건반은 3개의 도를 동시에 누를 수있지만 연주자가 더 힘들것이다.  
무느알?